\section{Graph Facilities \& Challenges}

Graph databases and distributed processing frameworks are two basic facilities to support our metadata graph model. Although there are already a large number of them, the challenges are still existing due to the specific requirements of storing, processing, and querying the large-scale metadata graphs.

\subsection{Graph Databases}
The graph databases are designed to cover the requirements of complex graph-based relationships, which embarrass the traditional relational databases. In the last couple of years, there have been an increasing number of graph databases implementation, including AllegroGraph, DEX, G-Store, HyperGraphDB, InfinitGraphDB, Neo4j, and Titan etc~\cite{allegrograph, dex, steinhaus2010g,  iordanov2010hypergraphdb, igraph, webber2012programmatic, titan}. They can be categorized based on different metrics. Based on storage device, there are in-memory databases and disk-based databases. Based on the supported graph data structure, there are {simple graphs} databases, {hypergraphs} databases, and {property graphs} databases\footnote{Here, the simple graph indicates graph defined as a set of nodes connected by weighted edges. Hypergraphs extends the simple graphs by allowing an edge to relate an arbitrary number of nodes~\cite{berge1973graphs}. Property graph indicates graph where nodes and edges contain properties. This property graph is the very basis of our proposed metadata graph model.}. Based on distributed deployment, there are single server databases, high availability databases, and distributed databases.\footnote{Here, the difference between high availability (HA) and distribution is HA only provides distributed reads on identical copies of the same dataset.}
%AllegroGraph and G-Store belong to this category. 
%Databases like HyperGraphDB and Sones support these hypergraphs. 
%Many databases like Neo4j, Titan, InfinitGraph, and DEX support such graphs. 

Among those graph databases, metadata graphs first requires a disk-based solution as they are too large to fit into memory; second, the supported graph structures should be property graph model. Also, the distribution supports will also be necessary since the graph size may overflow the disks of a single sever. There are several implementations that satisfy such requirements, like Titan, DEX, Neo4j etc. But, the challenge is the performance. Updating edges across different servers will significantly reduce the performance, so the graph databases should consider the structure of different entities and provide intelligent storage layout.  Another key performance challenge is graph traversal. In fact, traveling through a property graph like our metadata graph will be even more complex. The main reason is that, during traveling, we usually need to apply filter or computations on some properties like the provenance example shows. As these properties are too big to be fully cached in memory and loading them from persistent devices will introduce too many random seeking, we will need a intelligent cache strategy in our design too.
%the graph size, graph data structure, and storage layouts, all determine the traversal performance. For a moderate-sized simple graph. we may be able to perform traversal in memory. However,
\subsection{Graph Processing}

In addition to the graph databases, there are also graph processing frameworks which can be used to perform computation or queries on graphs in a distributed way. Typical examples of these frameworks include Gigraph~\cite{gigraph}, which was designed and implemented based on Pregel computing model~\cite{malewicz2010pregel}; GraphX~\cite{xin2013graphx}, which was based on Spark computing framework~\cite{zaharia2010spark}; GraphLab~\cite{low2010graphlab}, and X-Stream~\cite{roy2013x} etc. Those processing frameworks are a complement of the querying and searching from graph databases. For example, we can run \textit{community discovery} algorithms on metadata graph to find the `closely' data files. The results can be used to optimize physical placements for better I/O performance. These algorithms usually get the whole graph involved in the iterative computation and last a long time. 
%CSR or CSC 

However, most these distributed graph processing frameworks work on the unstructured graphs which are usually simply stored as a plain file in adjacency list formats in a general storage back-end. So, there is a big gap from deploying graph algorithms on these plain graph formats to running these algorithms on a graph database, which has an optimized storage layout for querying and searching.

%However, the ability to run complex graph algorithms is necessary for metadata management, and this ability can not be easily satisfied using the querying or searching facilities provided by graph databases. A distributed fault-tolerant graph processing model is a much better choice than writing applications to manage all these complexity.

%Moreover, whether support distributed deployment also classifies all these databases. Only part of them support distributed deployment due to the fact that partitioning graph into different servers with ACID guarantee and enough performance is challenge. 

%For example, Neo4j only supports high availability deployment, which means multiple copies of each data across the cluster rather than a distributing. 

%In addition to this, some graph databases support query languages. For example, Neo4j supports Cypher graph traversal language, Titan supports Gremlin language etc. Although most graph databases provide basic APIs to travel graphs, it is still more easy and efficient to use a query language. 
%\subsection{Storing and Indexing Requirement}

%\subsection{Traversal Requirement}

%The limitation of traditional databases especially the relational databases has lead the development of new categories of system called \textit{graph databases} to cover the requirements of complex graph-based relationships. In the last couple of years, there have been an increasing work about graph databases. Some popular graph databases include Sones, AllegroGraph, DEX, G-Store, HyperGraphDB, InfinitGraphDB, Neo4j, Titan, and OrientDB etc.